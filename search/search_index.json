{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 This is a tutorial to guide you through the process of creating your very own functional Discord bot in Python. It aims to help you understand the basic concepts of making a Discord bot, and help you all the way up to advanced concepts and features. This tutorial aims to cover 2 main libraries at the same time, Nextcord and Disnake. Multiple code tabs will be used to show each library's implementation of the feature being explained, looking like this: nextcord.py disnake.py import nextcord import disnake For specific help with each of these libraries please join their respective support servers: Nextcord Disnake Warning This is a tutorial intended for beginners to advanced bot developers, however it is not meant for beginner programmers, and contains advanced topics such as asynchronous programming. It is recommended that you have a firm grasp on Python and some of its more advanced concepts before you start developing bots, but it is not a hard requirement. If you have persistence and the willingness to learn and search for things you don't understand as you go along, you can learn both Python and bot development at the same time. Note This tutorial is a guide to help you create bots, it is not meant for you to copy the code of, as this does not help you learn. I highly recommend that you do not directly copy code from here, since it will not help in the long run. Start the Tutorial!","title":"Home"},{"location":"#home","text":"This is a tutorial to guide you through the process of creating your very own functional Discord bot in Python. It aims to help you understand the basic concepts of making a Discord bot, and help you all the way up to advanced concepts and features. This tutorial aims to cover 2 main libraries at the same time, Nextcord and Disnake. Multiple code tabs will be used to show each library's implementation of the feature being explained, looking like this: nextcord.py disnake.py import nextcord import disnake For specific help with each of these libraries please join their respective support servers: Nextcord Disnake Warning This is a tutorial intended for beginners to advanced bot developers, however it is not meant for beginner programmers, and contains advanced topics such as asynchronous programming. It is recommended that you have a firm grasp on Python and some of its more advanced concepts before you start developing bots, but it is not a hard requirement. If you have persistence and the willingness to learn and search for things you don't understand as you go along, you can learn both Python and bot development at the same time. Note This tutorial is a guide to help you create bots, it is not meant for you to copy the code of, as this does not help you learn. I highly recommend that you do not directly copy code from here, since it will not help in the long run. Start the Tutorial!","title":"Home"},{"location":"credits/","text":"Credits \u00b6 This page is to give credit to people who have helped with this tutorial, or people without whom the tutorial couldn't exist. Rapptz/Danny , for creating discord.py to start with. Nextcord & Disnake development teams & contributors for continuing the libraries as forks. Anand , TizzySaurus, and other contributos to the previous version of this tutorial. Me , I made this :P","title":"Credits"},{"location":"credits/#credits","text":"This page is to give credit to people who have helped with this tutorial, or people without whom the tutorial couldn't exist. Rapptz/Danny , for creating discord.py to start with. Nextcord & Disnake development teams & contributors for continuing the libraries as forks. Anand , TizzySaurus, and other contributos to the previous version of this tutorial. Me , I made this :P","title":"Credits"},{"location":"tips/tokens/","text":"Storing Tokens and Secrets \u00b6 In this tip article I'll explain the 3 most common methods of storing tokens and application secrets. While this is focused on use in Nextcord and Disnake projects, the concepts and tools are applicable to any project, should you wish to use this as a general reference. Note that for these examples you should assume that there is a bot defined somewhere else in the code, and the line bot.run(token) is at the bottom. I won't show the bot code in each example to show just the necessary information, and make this applicable outside of Discord bots too. Warning You should put all files storing credentials in your .gitignore file if you're using Git, so that they are not accidentally uploaded to Github (or your preferred git hosting provider). .env files \u00b6 The most common method of storing tokens and secrets is to store them in a .env file. This is a file which is used by the python-dotenv package to load environment variables from. This is the most common way of storing tokens and secrets in almost all programming projects. Note You will need to install the python-dotenv package to use this method. Linux and Mac Windows python3 -m pip install python-dotenv py -3 -m pip install python-dotenv .env main.py TOKEN=your_token from os import environ from dotenv import load_dotenv load_dotenv () token = environ [ \"TOKEN\" ] Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token ) Importing from Python files \u00b6 Another technique you can use is to import the token from a Python file. This is far simpler than loading from a .env file as it requires no external modules and is just a regular Python import. Assuming you have a folder named private and in it a file called config.py , you can simply use the following code to import the token from it: private/config.py main.py token = \"your_token\" from private.config import token Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token ) YAML and JSON \u00b6 The last common technique is using YAML and JSON files to store your token. First, I'll assume you have either a config.yml or config.json file. You're free to use whichever of these two you like, just look at the correct section for your type. YAML \u00b6 Note You will need to install the pyyaml package to use this method. Linux and Mac Windows python3 -m pip install pyyaml py -3 -m pip install pyyaml config.yml main.py token: \"your_token\" from yaml import safe_load from pathlib import Path config = safe_load ( Path ( \"config.yml\" ) . read_text ()) token = config [ \"token\" ] JSON \u00b6 For JSON it's more simple than YAML since no non-standard modules are needed, simply create a file ( config.json ) and load it as follows: config.json main.py { \"token\" : \"your_token\" } from json import loads from pathlib import Path config = loads ( Path ( \"config.json\" ) . read_text ()) token = config [ \"token\" ]","title":"Storing Tokens and Secrets"},{"location":"tips/tokens/#storing-tokens-and-secrets","text":"In this tip article I'll explain the 3 most common methods of storing tokens and application secrets. While this is focused on use in Nextcord and Disnake projects, the concepts and tools are applicable to any project, should you wish to use this as a general reference. Note that for these examples you should assume that there is a bot defined somewhere else in the code, and the line bot.run(token) is at the bottom. I won't show the bot code in each example to show just the necessary information, and make this applicable outside of Discord bots too. Warning You should put all files storing credentials in your .gitignore file if you're using Git, so that they are not accidentally uploaded to Github (or your preferred git hosting provider).","title":"Storing Tokens and Secrets"},{"location":"tips/tokens/#env-files","text":"The most common method of storing tokens and secrets is to store them in a .env file. This is a file which is used by the python-dotenv package to load environment variables from. This is the most common way of storing tokens and secrets in almost all programming projects. Note You will need to install the python-dotenv package to use this method. Linux and Mac Windows python3 -m pip install python-dotenv py -3 -m pip install python-dotenv .env main.py TOKEN=your_token from os import environ from dotenv import load_dotenv load_dotenv () token = environ [ \"TOKEN\" ] Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token )","title":".env files"},{"location":"tips/tokens/#importing-from-python-files","text":"Another technique you can use is to import the token from a Python file. This is far simpler than loading from a .env file as it requires no external modules and is just a regular Python import. Assuming you have a folder named private and in it a file called config.py , you can simply use the following code to import the token from it: private/config.py main.py token = \"your_token\" from private.config import token Now that you've loaded the token into the token variable, you can use it to run the bot in the bot.run() method: bot . run ( token )","title":"Importing from Python files"},{"location":"tips/tokens/#yaml-and-json","text":"The last common technique is using YAML and JSON files to store your token. First, I'll assume you have either a config.yml or config.json file. You're free to use whichever of these two you like, just look at the correct section for your type.","title":"YAML and JSON"},{"location":"tips/tokens/#yaml","text":"Note You will need to install the pyyaml package to use this method. Linux and Mac Windows python3 -m pip install pyyaml py -3 -m pip install pyyaml config.yml main.py token: \"your_token\" from yaml import safe_load from pathlib import Path config = safe_load ( Path ( \"config.yml\" ) . read_text ()) token = config [ \"token\" ]","title":"YAML"},{"location":"tips/tokens/#json","text":"For JSON it's more simple than YAML since no non-standard modules are needed, simply create a file ( config.json ) and load it as follows: config.json main.py { \"token\" : \"your_token\" } from json import loads from pathlib import Path config = loads ( Path ( \"config.json\" ) . read_text ()) token = config [ \"token\" ]","title":"JSON"},{"location":"tutorial/","text":"Tutorial - Home \u00b6 Before you start, there's a few things you will need to start developing bots: Nextcord Disnake An install of Python 3.8 or higher. An install of the Nextcord library. Linux and Mac Windows python3 -m pip install nextcord py -3 -m pip install nextcord An install of Python 3.8 or higher. An install of the Disnake library. Linux and Mac Windows python3 -m pip install disnake py -3 -m pip install disnake A working knowledge of Python basics or the will to learn. Especially object oriented programming. If you're unfamiliar with OOP in Python you can check out this tutorial by Corey Schafer. Now that you have these things you're ready to start the tutorial! Take Me to the Tutorial! Show Me the Credits","title":"Tutorial - Home"},{"location":"tutorial/#tutorial-home","text":"Before you start, there's a few things you will need to start developing bots: Nextcord Disnake An install of Python 3.8 or higher. An install of the Nextcord library. Linux and Mac Windows python3 -m pip install nextcord py -3 -m pip install nextcord An install of Python 3.8 or higher. An install of the Disnake library. Linux and Mac Windows python3 -m pip install disnake py -3 -m pip install disnake A working knowledge of Python basics or the will to learn. Especially object oriented programming. If you're unfamiliar with OOP in Python you can check out this tutorial by Corey Schafer. Now that you have these things you're ready to start the tutorial! Take Me to the Tutorial! Show Me the Credits","title":"Tutorial - Home"},{"location":"tutorial/beginner/01-setup/","text":"Creating a Bot User \u00b6 Info To create a bot application your Discord account must have a verified email address. It is also recommended that you enable 2-factor-authentication to secure your account. The first step in creating a bot is to head over to the Discord Developer Portal where you'll be asked to log in to your Discord account if you're not already signed in. Obce you've logged in you'll see a screen like this: You can now click the shiny blue New Application button in the top hand corner to get started creating a new application. After you click it you should see a box like this pop up: Enter a suitable name for your application, and make sure that it follow Discord's Terms of Service. This applies to the entire tutorial too - you should not be using this tutorial for purposes that violate Discord's Terms of Service, Community Guidelines, or Developer Terms. You can read the Terms of Service here , and the Developer Terms here . Warning As a rough overview here are some things you should know about the ToS: Don't abuse the API. Don't harass users. So don't randomly DM or spam them. Don't spam Discord. Generally actions performed by a bot should be caused by some user action like sending a message or adding a reaction. Don't post NSFW content in channels not marked as NSFW. This may seem obvious but a lot of bots allow NSFW content to be posted outside of NSFW channels. This is not allowed. For the purposes of this tutorial we'll be using the name WumpusBot , and this will be referred to in other places in the tutorial, for example screenshots of commands. After creating an application you'll see a screen like this: There's quite a lot of information on this screen, so for now we'll ignore most of it since it's out of scope for the beginning of this tutorial. Click on the Bot tab on the left hand side (marked by a jigsaw piece) to switch to the bot page. On this page you'll see a button that says Add Bot. Clicking this will prompt you asking whether you're sure you want to create a new bot (you can't delete bots since they're too cool to destroy), click Yes, do it! and now you have your very own bot. After creating a bot your screen will change to look like this: Below the username box you'll see a button that says Copy which copies your bot's authentication token to your clipboard. You'll want to keep this token safe and on hand so your bot can connect to Discord later on in the tutorial. Warning Make sure never to post your token anywhere publicly, else people will be able to log in as your bot, and perform actions against the Discord API as your bot. If you believe that your bot\u2019s token was leaked, be sure to go to it\u2019s developer portal page and click the Regenerate button to regenerate the token so that nobody can use the old one. Finally for this part, you need to add your bot to your server. To do this you first require the Manage Server permission in whatever server you plan on adding it to. You\u2019ll want to head over to the OAuth2 tab on the left of the developer portal (marked by a wrench), where you\u2019ll be able to choose the scopes you want for your bot. For now, just select the bot scope, as it\u2019s all that will be needed for this tutorial - at least at the beginning. Now you\u2019ll want to choose permissions for your bot based on what you want it to do. For WumpusBot, I\u2019ll start by giving it Send Messages , Embed Links , Attach Files , Manage Messages , and Add Reactions , although we may need more permissions later, but that will be handled within Discord itself. Warning There are almost no circumstances under which your bot will ever need the Administrator permission. If you do not absolutely need it, you should not have it, as bots with administrator can destroy servers in seconds by deleting channels, mass-banning members, and a multitude of other unpleasant actions. In the end your permissions should look like this: Now you can copy the URL in the box above, and paste it into your browser, then follow the steps to add the bot to your server of choice. As of late 2021 it is also possible to click invite links within Discord itself to add a bot to your server too. That's it for the first part of the tutorial, you've created your very own bot user on Discord. Now you just have to do the fun bit - adding features - after all, what's a bot without features?","title":"Creating a Bot User"},{"location":"tutorial/beginner/01-setup/#creating-a-bot-user","text":"Info To create a bot application your Discord account must have a verified email address. It is also recommended that you enable 2-factor-authentication to secure your account. The first step in creating a bot is to head over to the Discord Developer Portal where you'll be asked to log in to your Discord account if you're not already signed in. Obce you've logged in you'll see a screen like this: You can now click the shiny blue New Application button in the top hand corner to get started creating a new application. After you click it you should see a box like this pop up: Enter a suitable name for your application, and make sure that it follow Discord's Terms of Service. This applies to the entire tutorial too - you should not be using this tutorial for purposes that violate Discord's Terms of Service, Community Guidelines, or Developer Terms. You can read the Terms of Service here , and the Developer Terms here . Warning As a rough overview here are some things you should know about the ToS: Don't abuse the API. Don't harass users. So don't randomly DM or spam them. Don't spam Discord. Generally actions performed by a bot should be caused by some user action like sending a message or adding a reaction. Don't post NSFW content in channels not marked as NSFW. This may seem obvious but a lot of bots allow NSFW content to be posted outside of NSFW channels. This is not allowed. For the purposes of this tutorial we'll be using the name WumpusBot , and this will be referred to in other places in the tutorial, for example screenshots of commands. After creating an application you'll see a screen like this: There's quite a lot of information on this screen, so for now we'll ignore most of it since it's out of scope for the beginning of this tutorial. Click on the Bot tab on the left hand side (marked by a jigsaw piece) to switch to the bot page. On this page you'll see a button that says Add Bot. Clicking this will prompt you asking whether you're sure you want to create a new bot (you can't delete bots since they're too cool to destroy), click Yes, do it! and now you have your very own bot. After creating a bot your screen will change to look like this: Below the username box you'll see a button that says Copy which copies your bot's authentication token to your clipboard. You'll want to keep this token safe and on hand so your bot can connect to Discord later on in the tutorial. Warning Make sure never to post your token anywhere publicly, else people will be able to log in as your bot, and perform actions against the Discord API as your bot. If you believe that your bot\u2019s token was leaked, be sure to go to it\u2019s developer portal page and click the Regenerate button to regenerate the token so that nobody can use the old one. Finally for this part, you need to add your bot to your server. To do this you first require the Manage Server permission in whatever server you plan on adding it to. You\u2019ll want to head over to the OAuth2 tab on the left of the developer portal (marked by a wrench), where you\u2019ll be able to choose the scopes you want for your bot. For now, just select the bot scope, as it\u2019s all that will be needed for this tutorial - at least at the beginning. Now you\u2019ll want to choose permissions for your bot based on what you want it to do. For WumpusBot, I\u2019ll start by giving it Send Messages , Embed Links , Attach Files , Manage Messages , and Add Reactions , although we may need more permissions later, but that will be handled within Discord itself. Warning There are almost no circumstances under which your bot will ever need the Administrator permission. If you do not absolutely need it, you should not have it, as bots with administrator can destroy servers in seconds by deleting channels, mass-banning members, and a multitude of other unpleasant actions. In the end your permissions should look like this: Now you can copy the URL in the box above, and paste it into your browser, then follow the steps to add the bot to your server of choice. As of late 2021 it is also possible to click invite links within Discord itself to add a bot to your server too. That's it for the first part of the tutorial, you've created your very own bot user on Discord. Now you just have to do the fun bit - adding features - after all, what's a bot without features?","title":"Creating a Bot User"},{"location":"tutorial/beginner/02-overview/","text":"An Overview of Discord \u00b6 If you already have a decent understanding of WebSockets, the Discord API, and general Discord terminology, you can likely skip ahead to the next part in the tutorial. 1: The Gateway \u00b6 The gateway is just the Discord name for a WebSocket connection to Discord, following a specific protocol of packets that we need to send and receive. This is our bot's primary connection to Discord and means that instead of asking Discord repeatedly for events that have happened (known as polling), we just tell Discord which events we want to receive via gateway intents, and Discord will send us those events over the persistent socket we have connected with. When using client libraries like Nextcord and Disnake we don't need to worry too much about how this happens at such a low level, but it can help you to understand how each of the cogs in the machine works. Often it's helpful to understand the low-level architecture of a service like Discord, as it gives you a better understanding of how the service works at a higher level. Upon receiving an event from the gateway, the library will check the OP code of the packet, and then call the appropriate function in the library. Many of these OP codes are internal, such as resuming a session, identifying the client, and sending heartbeats, but some, like OP 10 (READY), are also dispatched as user facing events (specifically on_ready in this instance). Events with OP 0 - dispatch events, are the ones we will primarily use, as they contain events like MESSAGE_CREATE, MEMBER_UPDATE, and all the other useful events for building a functional bot. That's pretty much it for the gateway at this level. There is a lot more detail that can be talked about with the gateway, but that's out of the scope of this tutorial, and if you're interested in further reading the official Discord documentation for the gateway can be found here . 2: The API \u00b6 The API is how out bots talk back to Discord. We're receiving events from the gateway which deliver information to our bot, but when we want to resond to one of these events, for example automatically deleting a message with banned words in it, we need to make a request to Discord's REST API telling it to delete that message. If you've ever sent a message on Discord, added a reaction, renamed a channel, or done just about any other action in the client, you've interacted with the API before, you just haven't seen it. Bots have most of the same endpoints available as regular users, bar a few like adding friends, blocking people, and joining guilds. They do, however, have certain features exclusive to bots, like the ability to lock emojis to members with a certain role. As with the gateway, API calls are done behind the scenes and you don't need to manually interact with the API. This is useful as it abstracts away the difficult points of passing headers and handling ratelimits. 3: Terminology \u00b6 In Discord there are a few special words for things which we need to understand and be able to differentiate between. The following table shows what a word means in the context of this tutorial. Term Description guild The internal word that Discord has for what you know as a server. user A Discord user, not containing information relating to a guild. member A Discord user, with guild context. You'll only receive members if you have the server members gateway intent enabled, which will be explained later, or sometimes in other events like voice state updates and as the author in message events. And that's pretty much it for this part of the tutorial. I hope this has given you at least some useful knowledge about roughly how Discord works, and now you can move on to the next part!","title":"An Overview of Discord"},{"location":"tutorial/beginner/02-overview/#an-overview-of-discord","text":"If you already have a decent understanding of WebSockets, the Discord API, and general Discord terminology, you can likely skip ahead to the next part in the tutorial.","title":"An Overview of Discord"},{"location":"tutorial/beginner/02-overview/#1-the-gateway","text":"The gateway is just the Discord name for a WebSocket connection to Discord, following a specific protocol of packets that we need to send and receive. This is our bot's primary connection to Discord and means that instead of asking Discord repeatedly for events that have happened (known as polling), we just tell Discord which events we want to receive via gateway intents, and Discord will send us those events over the persistent socket we have connected with. When using client libraries like Nextcord and Disnake we don't need to worry too much about how this happens at such a low level, but it can help you to understand how each of the cogs in the machine works. Often it's helpful to understand the low-level architecture of a service like Discord, as it gives you a better understanding of how the service works at a higher level. Upon receiving an event from the gateway, the library will check the OP code of the packet, and then call the appropriate function in the library. Many of these OP codes are internal, such as resuming a session, identifying the client, and sending heartbeats, but some, like OP 10 (READY), are also dispatched as user facing events (specifically on_ready in this instance). Events with OP 0 - dispatch events, are the ones we will primarily use, as they contain events like MESSAGE_CREATE, MEMBER_UPDATE, and all the other useful events for building a functional bot. That's pretty much it for the gateway at this level. There is a lot more detail that can be talked about with the gateway, but that's out of the scope of this tutorial, and if you're interested in further reading the official Discord documentation for the gateway can be found here .","title":"1: The Gateway"},{"location":"tutorial/beginner/02-overview/#2-the-api","text":"The API is how out bots talk back to Discord. We're receiving events from the gateway which deliver information to our bot, but when we want to resond to one of these events, for example automatically deleting a message with banned words in it, we need to make a request to Discord's REST API telling it to delete that message. If you've ever sent a message on Discord, added a reaction, renamed a channel, or done just about any other action in the client, you've interacted with the API before, you just haven't seen it. Bots have most of the same endpoints available as regular users, bar a few like adding friends, blocking people, and joining guilds. They do, however, have certain features exclusive to bots, like the ability to lock emojis to members with a certain role. As with the gateway, API calls are done behind the scenes and you don't need to manually interact with the API. This is useful as it abstracts away the difficult points of passing headers and handling ratelimits.","title":"2: The API"},{"location":"tutorial/beginner/02-overview/#3-terminology","text":"In Discord there are a few special words for things which we need to understand and be able to differentiate between. The following table shows what a word means in the context of this tutorial. Term Description guild The internal word that Discord has for what you know as a server. user A Discord user, not containing information relating to a guild. member A Discord user, with guild context. You'll only receive members if you have the server members gateway intent enabled, which will be explained later, or sometimes in other events like voice state updates and as the author in message events. And that's pretty much it for this part of the tutorial. I hope this has given you at least some useful knowledge about roughly how Discord works, and now you can move on to the next part!","title":"3: Terminology"},{"location":"tutorial/beginner/03-hello/","text":"Hello, world \u00b6 In this part we'll create a basic slash command which just responds with \"Hello, world!\" to a /hello command. From this point onwards it is expected that you have either Nextcord or Disnake installed, as well as Python 3.8 or above. Nextcord Disnake To start off with slash commands in Nextcord, we'll need to import the nextcord.Client class, and create an instance of it which we can create commands on: import nextcord client = nextcord . Client () Awesome! Now that we have an instance of the client, we can create a command which responds to the /hello command: @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @client.slash_command(...) is a decorator which tells Nextcord that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: nextcord.Interaction) -> None is the function which will be called when the command is triggered. await inter.response.send_message(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Client.run() : client . run ( \"YOUR_BOT_TOKEN\" ) To start off with slash commands in Disnake we'll need to import the commands.Bot class, and also the ApplicationCommandInteraction class for later use when defining the command: from disnake import ApplicationCommandInteraction from disnake.ext.commands import Bot bot = Bot () Warning Remember, how you name your variables is important! This variable should be named bot , as it is an instance of the Bot class, and not something like client , which is a different class entirely. Awesome! Now that we have an instance of the bot, we can create a command which responds to the /hello command: @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : ApplicationCommandInteraction ) -> None : await inter . send ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @bot.slash_command(...) is a decorator which tells Disnake that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: ApplicationCommandInteraction) -> None is the function which will be called when the command is triggered. await inter.send(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Bot.run() : bot . run ( \"YOUR_BOT_TOKEN\" ) Warning Storing tokens in your code like this is dangerous, if you upload a sample of your code to somewhere like Pastebin people could get your token and use it maliciously. It is recommended that you always store tokens in an environment variable or file, which is ignored by your version control system like Git. See Storing Tokens and Secrets for more information about how to correctly store application credentials. In the end you should have a command that looks like this: vcokltfre used /hello WumpusBot BOT Hello! That's it for this part! You're now ready to move on to ever more green and complex pastures!","title":"Hello, world"},{"location":"tutorial/beginner/03-hello/#hello-world","text":"In this part we'll create a basic slash command which just responds with \"Hello, world!\" to a /hello command. From this point onwards it is expected that you have either Nextcord or Disnake installed, as well as Python 3.8 or above. Nextcord Disnake To start off with slash commands in Nextcord, we'll need to import the nextcord.Client class, and create an instance of it which we can create commands on: import nextcord client = nextcord . Client () Awesome! Now that we have an instance of the client, we can create a command which responds to the /hello command: @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @client.slash_command(...) is a decorator which tells Nextcord that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: nextcord.Interaction) -> None is the function which will be called when the command is triggered. await inter.response.send_message(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Client.run() : client . run ( \"YOUR_BOT_TOKEN\" ) To start off with slash commands in Disnake we'll need to import the commands.Bot class, and also the ApplicationCommandInteraction class for later use when defining the command: from disnake import ApplicationCommandInteraction from disnake.ext.commands import Bot bot = Bot () Warning Remember, how you name your variables is important! This variable should be named bot , as it is an instance of the Bot class, and not something like client , which is a different class entirely. Awesome! Now that we have an instance of the bot, we can create a command which responds to the /hello command: @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : ApplicationCommandInteraction ) -> None : await inter . send ( \"Hello!\" ) There's quite a lot going on in that snippet, so allow me to explain what it all does: @bot.slash_command(...) is a decorator which tells Disnake that this is a slash command. name=\"hello\" is the name of the command. description=\"A simple hello command.\" is the description of the command. guild_ids=[...] is a list of guild IDs which the command is registered in, these should be int IDs of the guilds you want to register the command in. If this is empty it will be registered in all guilds, taking up to an hour to globally register. async def hello(inter: ApplicationCommandInteraction) -> None is the function which will be called when the command is triggered. await inter.send(\"Hello!\") is the response which will be sent to the user. Finally, we can connect our bot to Discord by using Bot.run() : bot . run ( \"YOUR_BOT_TOKEN\" ) Warning Storing tokens in your code like this is dangerous, if you upload a sample of your code to somewhere like Pastebin people could get your token and use it maliciously. It is recommended that you always store tokens in an environment variable or file, which is ignored by your version control system like Git. See Storing Tokens and Secrets for more information about how to correctly store application credentials. In the end you should have a command that looks like this: vcokltfre used /hello WumpusBot BOT Hello! That's it for this part! You're now ready to move on to ever more green and complex pastures!","title":"Hello, world"},{"location":"tutorial/beginner/04-pong/","text":"A Ping Command \u00b6 So far our bot is pretty simple - you type /hello and the bot responds with \"Hello!\" as a static response, which isn't particularly interesting. In this tutorial part we'll use useful information from our bot - its gateway latency - to respond with a more interesting response about the bot's performance. Here's the code from the previous part: Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import ApplicationCommandInteraction from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : ApplicationCommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) The code we will be writing in a second will go just above the bot.run() call. Firstly we'll start out by defining the command again: Nextcord Disnake @client . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : nextcord . Interaction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . response . send_message ( f \"Pong! { client . latency * 1000 : .2f } ms\" ) @bot . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : ApplicationCommandInteraction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . send ( f \"Pong! { bot . latency * 1000 : .2f } ms\" ) Note The final line here is indented by one indent. Make sure to reflect this in your own code. Most of this you have seen before in the previous part, but the important bit is the line which says either: await inter.response.send_message(f\"Pong! {client.latency * 1000:.2f}ms\") (Nextcord) await inter.send(f\"Pong! {bot.latency * 1000:.2f}ms\") (Disnake) The latency property of the bot or client tells us in seconds how long it took for the Discord gateway to respond to us last time we sent it a heartbeat payload (which keeps the connection alive). We multiply this by 1000 to get the latency in milliseconds, which is better for being interpreted, and is more standard, and then we round it to 2 decimal places using the :.2f format specifier. Now you can once again run your bot - having changed the guild_ids=[...] to contain your own guild IDs - and you'll be able to use the command like this: vcokltfre used /ping WumpusBot BOT Pong! 23.5ms That's it for this part! Now you're ready to move on to the next part: listening for events!","title":"A Ping Command"},{"location":"tutorial/beginner/04-pong/#a-ping-command","text":"So far our bot is pretty simple - you type /hello and the bot responds with \"Hello!\" as a static response, which isn't particularly interesting. In this tutorial part we'll use useful information from our bot - its gateway latency - to respond with a more interesting response about the bot's performance. Here's the code from the previous part: Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import ApplicationCommandInteraction from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : ApplicationCommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) The code we will be writing in a second will go just above the bot.run() call. Firstly we'll start out by defining the command again: Nextcord Disnake @client . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : nextcord . Interaction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . response . send_message ( f \"Pong! { client . latency * 1000 : .2f } ms\" ) @bot . slash_command ( name = \"ping\" , description = \"A simple ping command.\" , guild_ids = [ ... ], ) async def ping ( inter : ApplicationCommandInteraction ) -> None : And next we'll add in the magical line which shows us the bot's latency: await inter . send ( f \"Pong! { bot . latency * 1000 : .2f } ms\" ) Note The final line here is indented by one indent. Make sure to reflect this in your own code. Most of this you have seen before in the previous part, but the important bit is the line which says either: await inter.response.send_message(f\"Pong! {client.latency * 1000:.2f}ms\") (Nextcord) await inter.send(f\"Pong! {bot.latency * 1000:.2f}ms\") (Disnake) The latency property of the bot or client tells us in seconds how long it took for the Discord gateway to respond to us last time we sent it a heartbeat payload (which keeps the connection alive). We multiply this by 1000 to get the latency in milliseconds, which is better for being interpreted, and is more standard, and then we round it to 2 decimal places using the :.2f format specifier. Now you can once again run your bot - having changed the guild_ids=[...] to contain your own guild IDs - and you'll be able to use the command like this: vcokltfre used /ping WumpusBot BOT Pong! 23.5ms That's it for this part! Now you're ready to move on to the next part: listening for events!","title":"A Ping Command"},{"location":"tutorial/beginner/05-listeners/","text":"Event Listeners \u00b6 While a lot of bot functionality can be implemented with slash commands, there are features that cannot be implemented like this. For example if you want to delete messages containing a certain keyword, you cannot do that with slash commands, but you can do it with listeners for other events, such as messages. Just like previous parts we'll want a basic bot to be set up. In this example we will be automatically deleting any message that contains the word \"badword\" in it. For simplicity I have removed the ping command from the basic bots below. Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import ApplicationCommandInteraction , Message from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : ApplicationCommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note We are importing Message here so that we can typehint the message parameter of the on_message listener later on. Next we'll create a listener that will delete any message that contains the word \"badword\" in it, again this is inserted just above the bot.run() call: Nextcord Disnake @client . event async def on_message ( message : nextcord . Message ) -> None : if \"badword\" in message . content : await message . delete () @bot . event async def on_message ( message : Message ) -> None : if \"badword\" in message . content : await message . delete () Here's a breakdown of what we're doing here: @bot.event is a decorator which tells Disnake that this is an event listener. async def on_message(message: Message) -> None is the function which will be called when the event is triggered. message is the message that triggered the event. if \"badword\" in message.content is a check to see if the message contains the word \"badword\" in it. await message.delete() is the response which will be sent to the user. Note This is a very simple example of using a listener for events. Much more complex tasks can be achieved using listeners, but they are out of scope for this beginner part. More complex examples will be given in later intermediate parts.","title":"Event Listeners"},{"location":"tutorial/beginner/05-listeners/#event-listeners","text":"While a lot of bot functionality can be implemented with slash commands, there are features that cannot be implemented like this. For example if you want to delete messages containing a certain keyword, you cannot do that with slash commands, but you can do it with listeners for other events, such as messages. Just like previous parts we'll want a basic bot to be set up. In this example we will be automatically deleting any message that contains the word \"badword\" in it. For simplicity I have removed the ping command from the basic bots below. Nextcord Disnake import nextcord client = nextcord . Client () @client . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : nextcord . Interaction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) from disnake import ApplicationCommandInteraction , Message from disnake.ext.commands import Bot bot = Bot () @bot . slash_command ( name = \"hello\" , description = \"A simple hello command.\" , guild_ids = [ ... ], ) async def hello ( inter : ApplicationCommandInteraction ) -> None : await inter . response . send_message ( \"Hello!\" ) bot . run ( \"YOUR_BOT_TOKEN\" ) Note We are importing Message here so that we can typehint the message parameter of the on_message listener later on. Next we'll create a listener that will delete any message that contains the word \"badword\" in it, again this is inserted just above the bot.run() call: Nextcord Disnake @client . event async def on_message ( message : nextcord . Message ) -> None : if \"badword\" in message . content : await message . delete () @bot . event async def on_message ( message : Message ) -> None : if \"badword\" in message . content : await message . delete () Here's a breakdown of what we're doing here: @bot.event is a decorator which tells Disnake that this is an event listener. async def on_message(message: Message) -> None is the function which will be called when the event is triggered. message is the message that triggered the event. if \"badword\" in message.content is a check to see if the message contains the word \"badword\" in it. await message.delete() is the response which will be sent to the user. Note This is a very simple example of using a listener for events. Much more complex tasks can be achieved using listeners, but they are out of scope for this beginner part. More complex examples will be given in later intermediate parts.","title":"Event Listeners"}]}